//go:build ignore

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io"
	"minesweeper/misc"
	"os"
	"os/exec"
	"slices"
	"strconv"
	"strings"
	"sync"
	"text/template"
	"unicode"
)

var TemplateTxt string = `
// do not edit!
// generated by sound_srcs_gen.go

package minesweeper

import (
	_ "embed"
)

// ===========================================================
// Sound files are embedded in EmbeddedSoundsData
// as a binary blob.
//
// And you can access them using EmbeddedSounds.
//
// It was done in this way instead of using embed package
// because I needed to embed audio files in absolute paths
// for prototyping. And that isn't allowed in embed package.
// ===========================================================

//go:embed sound_srcs_bin
var EmbeddedSoundsData []byte

type EmbeddedSound struct {
	Offset int
	Len int

	ConvertedToMp3WithFfmpeg bool
}

var EmbeddedSounds = map[string]EmbeddedSound {
{{- range $path, $embeddedSound := .EmbeddedSounds}}
	{{quote $path}} : {
		Offset : {{$embeddedSound.Offset}},
		Len : {{$embeddedSound.Len}},

		ConvertedToMp3WithFfmpeg : {{$embeddedSound.ConvertedToMp3WithFfmpeg}},
	},
{{- end}}
}

const (
{{- range .NameAndPaths}}
	{{.Name}} = "{{.Path}}"
{{- end}}
)

var SoundSrcs = []string {
{{- range $_, $path := .Paths}}
	"{{$path}}",
{{- end}}
}
`

type NameAndPath struct {
	Name string
	Path string
}

type EmbeddedSound struct {
	Offset int
	Len    int

	ConvertedToMp3WithFfmpeg bool
}

func main() {
	const soundSrcsTxt = "sound_srcs.txt"
	const soundSrcsLocalTxt = "sound_srcs_local.txt"

	// ================================
	// check if src files exist
	// ================================
	soundSrcsTxtExists, err := misc.CheckFileExists(soundSrcsTxt)
	if err != nil {
		misc.ErrLogger.Fatal(err)
	}

	soundSrcsLocalTxtExists, err := misc.CheckFileExists(soundSrcsLocalTxt)
	if err != nil {
		misc.ErrLogger.Fatal(err)
	}

	if !soundSrcsTxtExists && !soundSrcsLocalTxtExists {
		misc.ErrLogger.Fatalf("needs file %s or %s", soundSrcsTxt, soundSrcsLocalTxt)
	}

	// ================================
	// gather nameAndPaths
	// ================================
	var nameAndPaths []NameAndPath

	if soundSrcsTxtExists {
		arr, err := ParseSoundSrcText(soundSrcsTxt)
		if err != nil {
			misc.ErrLogger.Fatalf("failed to parse %s: %v", soundSrcsTxt, err)
		}
		nameAndPaths = append(nameAndPaths, arr...)
	}

	if soundSrcsLocalTxtExists {
		arr, err := ParseSoundSrcText(soundSrcsLocalTxt)
		if err != nil {
			misc.ErrLogger.Fatalf("failed to parse %s: %v", soundSrcsLocalTxt, err)
		}

		for _, newNameAndPath := range arr {
			doAppend := true

			for i, nameAndPath := range nameAndPaths {
				if nameAndPath.Name == newNameAndPath.Name {
					nameAndPaths[i] = newNameAndPath
					doAppend = false
				}
			}

			if doAppend {
				nameAndPaths = append(nameAndPaths, newNameAndPath)
			}
		}
	}

	var paths []string
	{
		pathMap := make(map[string]bool)

		for _, nameAndPath := range nameAndPaths {
			pathMap[nameAndPath.Path] = true
		}

		for path := range pathMap {
			paths = append(paths, path)
		}

		slices.SortFunc(paths, func(a, b string) int {
			return strings.Compare(a, b)
		})
	}

	const binOutput = "sound_srcs_bin"
	var embeddedSounds map[string]EmbeddedSound

	if misc.CheckExeExists("ffmpeg") {
		misc.InfoLogger.Print("using ffmpeg to converting audio to vorbis ogg")
		embeddedSounds, err = GenerateEmbeddedSoundsUseFfmpeg(paths, binOutput)
	} else {
		misc.WarnLogger.Print("couldn't find ffmpeg, embedding audio directly without converting to vorbis ogg")
		embeddedSounds, err = GenerateEmbeddedSounds(paths, binOutput)
	}

	if err != nil {
		misc.ErrLogger.Fatalf("faile to generate %s: %v", binOutput, err)
	}

	// ================================
	// generate sound_srcs.go
	// ================================
	buff := &bytes.Buffer{}

	//tmpl, err := template.New("sound_src_template").Parse(TemplateTxt)
	tmpl := template.New("sound_src_template")
	tmpl.Funcs(map[string]any{"quote": strconv.Quote})
	tmpl, err = tmpl.Parse(TemplateTxt)
	if err != nil {
		misc.ErrLogger.Fatal(err)
	}

	err = tmpl.Execute(buff, struct {
		NameAndPaths   []NameAndPath
		Paths          []string
		EmbeddedSounds map[string]EmbeddedSound
	}{
		NameAndPaths:   nameAndPaths,
		Paths:          paths,
		EmbeddedSounds: embeddedSounds,
	})
	if err != nil {
		misc.ErrLogger.Fatal(err)
	}
	formatted, err := format.Source(buff.Bytes())
	if err != nil {
		misc.ErrLogger.Fatal(err)
	}

	os.WriteFile("sound_srcs.go", formatted, 0664)
}

func ParseSoundSrcText(path string) ([]NameAndPath, error) {
	srcBytes, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	srcTxt := string(srcBytes)
	srcTxt = strings.ReplaceAll(srcTxt, "\r\n", "\n")

	var nameAndPaths []NameAndPath

	lines := strings.Split(srcTxt, "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)

		if strings.HasPrefix(line, "//") {
			continue
		}

		var name string

		for i, r := range line {
			if unicode.IsSpace(r) {
				name = line[0:i]
				line = line[i:]
				break
			}
		}

		line = strings.TrimSpace(line)
		line = strings.Trim(line, "\"'")

		var path = line

		path = strings.ReplaceAll(path, "\\", "/")

		if len(name) > 0 && len(path) > 0 {
			nameAndPaths = append(nameAndPaths, NameAndPath{
				Name: name,
				Path: path,
			})
		}
	}

	return nameAndPaths, nil
}

func GenerateEmbeddedSounds(
	paths []string,
	binOutput string,
) (map[string]EmbeddedSound, error) {
	var sumedFile []byte
	var offset int
	embeddedSounds := make(map[string]EmbeddedSound)

	for _, path := range paths {
		file, err := os.ReadFile(path)
		if err != nil {
			return nil, err
		}

		embeddedSound := EmbeddedSound{
			Offset: offset,
			Len:    len(file),
		}
		offset += len(file)
		embeddedSounds[path] = embeddedSound

		sumedFile = append(sumedFile, file...)
	}

	err := os.WriteFile(binOutput, sumedFile, 0644)
	if err != nil {
		return nil, err
	}

	return embeddedSounds, nil
}

func GenerateEmbeddedSoundsUseFfmpeg(
	paths []string,
	binOutput string,
) (map[string]EmbeddedSound, error) {
	type ffmpegThread struct {
		Path           string
		ConvertedAudio []byte

		// error when running the command
		// ExitCode maybe zero even when Error is not nil,
		// that means we couldn't even run the command
		Error error

		ExitCode int
		Stderr   []byte
	}

	var wg sync.WaitGroup
	threads := make([]ffmpegThread, len(paths))

	for i, path := range paths {
		wg.Add(1)

		go func() {
			thread := ffmpegThread{}

			defer func() {
				thread.Path = path
				threads[i] = thread
				wg.Done()
			}()

			cmd := exec.Command(
				"ffmpeg",
				"-i", path, // input file
				"-f", "mp3", // container format
				"-c:a", "libmp3lame", // vorbis
				"-vn",      // no video
				"-ac", "2", // 2 audio channel
				"-q:a", "5", // variable bitrate quality 5
				"pipe:1", // use stdout as pipe
			)
			misc.InfoLogger.Printf("%s", cmd.String())

			stdout, err := cmd.StdoutPipe()
			if err != nil {
				thread.Error = err
				return
			}
			stderr, err := cmd.StderrPipe()
			if err != nil {
				thread.Error = err
				return
			}

			err = cmd.Start()
			if err != nil {
				thread.Error = err
				return
			}

			converted, err := io.ReadAll(stdout)
			if err != nil {
				thread.Error = err
				return
			}
			stderrCollected, err := io.ReadAll(stderr)
			if err != nil {
				thread.Error = err
				return
			}

			err = cmd.Wait()
			if err != nil {
				// check if it's exit error
				if exitErr, ok := err.(*exec.ExitError); ok {
					// something went wrong on ffmpeg side
					thread.Error = exitErr
					thread.ExitCode = exitErr.ExitCode()
					thread.Stderr = stderrCollected
				} else {
					// something went wrong on our side
					thread.Error = err
				}
				return
			}
			thread.ConvertedAudio = converted
		}()
	}

	wg.Wait()

	failed := false

	for _, thread := range threads {
		if thread.Error != nil {
			failed = true
			if len(thread.Stderr) > 0 {
				fmt.Fprint(os.Stderr, "\n")
				misc.ErrLogger.Printf("ffmpeg failed to convert %s", thread.Path)
				os.Stderr.Write(thread.Stderr)
			}
		}
	}

	if failed {
		return nil, fmt.Errorf("failed to convert audio using ffmpeg")
	}

	var sumedFile []byte
	var offset int
	embeddedSounds := make(map[string]EmbeddedSound)

	for _, thread := range threads {
		embeddedSound := EmbeddedSound{
			Offset:                   offset,
			Len:                      len(thread.ConvertedAudio),
			ConvertedToMp3WithFfmpeg: true,
		}
		offset += len(thread.ConvertedAudio)
		embeddedSounds[thread.Path] = embeddedSound

		sumedFile = append(sumedFile, thread.ConvertedAudio...)
	}

	err := os.WriteFile(binOutput, sumedFile, 0644)
	if err != nil {
		return nil, err
	}

	return embeddedSounds, nil
}
